DOCUMENTACION 
-------------

SimpleRest utiliza la arquitectura MVC donde modelos y controladores se implementan con clases y las vistas con archivos planos.

# Estructura del proyecto

```
├── app                           # Main MVC file structure directory
│   ├── controllers               # Controllers directory 
│   ├── models                    # Models directory
│   ├── views                     # Views directory
│   ├── api                       # Resource controller Directory
│   ├── libs                      
│   ├── locale                    # i18n translations
│   └── core                      # Core directory
|
├── core                          # Basically mvc engine directory
│   ├── api
|   |   ├── v1
|   |   ├── v2
|   |   └── vN
│   ├── exceptions
│   ├── interfaces                          
│   └── config                    # Configuration directory
│       ├── config.php          
│       └── constants.php           
│         
├── public
|   ├── assets                     
│   |   ├── css               
│   |   ├── img    
|   |   └── js
|   ├── .htaccess      
|   ├──  index.php
|   └──  favicon.ico
|
├─── vendor                    
└── .htaccess                     
```


# Versionado

Se especifica la versión en la url y esto tiene como efecto cargar una versión distinta de la clase ApiController en /app/core/api

	GET /api/v1/products
	GET /api/v2/products
	GET /api/v3/products

En el primer por ejemplo caso carga la clase /app/core/api/v1/v1/ApiController

La clase MyApiController en /app/controllers es la responsable de seleccionar la versión solicitada de la API.


### Controlador

Para demostrar como ejecutar un controlador desde la linea de comandos ejemplificaremos con un simple controlador ubicado en la carpeta controllers:

	<?php

	namespace simplerest\controllers;

	class DumbController extends Controller
	{

		function add($a, $b){
			$res = (int) $a + (int) $b;
			return  "$a + $b = " . $res;
		}

	}

En la terminal nos cambiamos al directorio "public" y ejecutamos: 

	php index.php dumb add 1 6

* Hay soporte para sub-directorios o sub-sub-(sub)-directorios 

### Modelo

	Cada modelo es definido en una clase en /app/models que extiende a Model y donde se define el schema y algunas propiedades de los campos. Ejemplo:


	class ProductsModel extends Model 
	{
		protected $table_name = "products";
		protected $id_name = 'id';
		protected $nullable = ['workspace', 'created'];
	 
		/*
			Types are INT, STR and BOOL among others
			see: https://secure.php.net/manual/en/pdo.constants.php 
		*/
		protected $schema = [
			'id' => 'INT',
			'name' => 'STR',
			'description' => 'STR',
			'size' => 'STR',
			'cost' => 'INT',
			'created' => 'STR',
			'modified' => 'STR',
			'workspace' => 'STR', 
			'belongs_to' => 'INT'  
		];

	    function __construct($db = NULL){
			parent::__construct($db);
		}

	}

Cada campo en el schema es de un tipo, el nombre de la tabla se especifica en $table_name aunque se recomienda que coincida con el nombre de la clase modelo en minúsculas. 

Todas las tablas deben tener un único id inclusive si son "tablas intermedias" (conocidas también como "tablas puente") y se especifica en la propiedad $id_name.

Los campos que pueden ser rellenados al hacer un INSERT o un UPDATE pueden especificarse dentro del array $fillable. 

Si un campo puede ser NULL, debe incluirse en el array $nullable.

Los modelos heredan de la clase Model y adquieren así funcionalidad de métodos como create() delete() update() join() where() having() etc


### Accesors

Se presentan casos donde es necesario hacer una transformación de los datos antes de guardarlos en base de datos. El caso emblemático es cuando se requiere hacer un "hash" del password antes de guardarse ya sea en la creación o edición de un registro.

Es posible definir "accesors" (conocidos también como "mutators") que interceptan esos valores y les aplican una función. Ejemplo:

class UsersModel extends Model
{ 
	// ...

    function __construct($db = NULL){
		
		$this->accesorRegister([ 
			'password'  => function($pass){ return password_hash($pass, PASSWORD_DEFAULT); }
		]);

        parent::__construct($db);
    }
}

El procedimiento es registrar los mutators para cada campo del modelo.


### Campos fillables, no-fillables, nullables y ocultos

Se puede definir un array de campos "fillables" aunque por lo general se lo puede dejar en automático. También es posible definir por el contrario, campos a excluir como "no fillables".

	protected $fillable = [
							'email',
							'password',
							'firstname',
							'lastname',
							'deleted_at',
							'belongs_to'
	];

	// o ...
	protected $not_fillable = ['confirmed_email'];

Los campos no-nullables serian los requeridos para las validaciones y se definen de igual modo: 

	protected $nullable = ['id', 'firstname', 'lastname', 'deleted_at', 'belongs_to', 'confirmed_email'];

Por último tenemos los campos ocultos:

	protected $hidden   = [	'password' ];


### Validaciones

El framework incluye un validador que está integrado a nivel de la API Rest y puede también incluirse a nivel de los modelos o bien usarse de forma aislada.

Para mostrar el funcionamiento de la clase Validator consideremos el siguiente ejemplo:

	$data = [
				'nombre'=>'Pablo1',
				'apellido'=>'Bz',
				'segundo_apellido'=>'San Martín',
				'usuario'=>'',
				'celular'=>'321530', 
				'correo'=>'a@b',
				'calle'=>'0',
				'numero_de_casa'=>'',
				'observaciones'=>'la vida es complicada y bla bla bla bla bla bla bla',
				'fecha'=>'32-09-2019',
				'hora'=>'24:00:17',
				'rol'=>'',
				'fuerza'=>'100.xxx',
				'estrato'=>'3',
				'felicidad'=>'0.25',
				'energia'=>'.25',
				'hora_almuerzo'=>'13:30:00',
				'hora_cena'=>'18:00:00',
				'fecha_nac'=>'10-12-1902',
				'frutas_favoritas'=>['bananas','manzanas']  // podria provenir de un grupo de checkboxes
				
	];

	$rules = [
				'nombre' 			=> ['type'=>'alpha','required'=>true],
				'apellido' 			=> ['type'=>'alpha','required'=>true,'min'=>3,'max'=>30],
				'segundo_apellido'	=> ['type'=>'alpha','required'=>true,'min'=>3,'max'=>30],
				'usuario' 			=> ['required'=>true,'min'=>2,'max'=>15],
				'celular' 			=> ['type'=>'regex:/^[0-9]{10}$/','required'=>true],
				'correo' 			=> ['type'=>'email','required'=>true], 
				'calle' 			=> ['type'=>'int','required'=>false, 'min'=>1],
				'numero_de_casa'    => ['type'=>'numeric','required'=>false],
				'observaciones' 	=> ['type'=>'string','max'=>40],
				'fecha' 			=> ['type'=>'date'], 
				'hora' 				=> ['type'=>'time'], 
				'rol' 				=> ['type'=>'int','required'=>false], 
				'fuerza' 			=> ['type'=>'decimal','required'=>false],
				'estrato' 			=> ['type'=>'int','required'=>false, 'min'=>1, 'max'=>6],
				'felicidad' 		=> ['type'=>'int','required'=>false, 'min'=>0, 'max'=>100],
				'energia' 			=> ['type'=>'decimal','required'=>false, 'min'=>0, 'max'=>100],
				'hora_almuerzo' 	=> ['type'=>'time','min'=>'11:00:00','max'=>'10:15:00'],
				'hora_cena' 		=> ['type'=>'time','min'=>'19:00:00','max'=>'22:30:00'],
				'fecha_nac' 		=> ['type'=>'date','min'=>'01-01-1980','max'=>'12-12-2018'],
				'frutas_favoritas' 	=> ['type'=>'array','min'=>3]
				
	];

	$validado = (new Validator())->validate($rules,$data);

	if ($validado !== true)
		var_dump($validado);

La salida en caso de fracaso es un array conteniendo las reglas rotas para cada campo:

	array(14) {
	["nombre"]=>
	array(1) {
		[0]=>
		array(3) {
		["dato"]=>
		string(10) "Sebastian1"
		["error"]=>
		string(4) "type"
		["error_msg"]=>
		string(11) "no es alpha"
		}
	}
	["usuario"]=>
	array(1) {
		[0]=>
		array(3) {
		["dato"]=>
		string(0) ""
		["error"]=>
		string(8) "required"
		["error_msg"]=>
		string(20) "usuario es requerido"
		}
	}
	["celular"]=>
	array(1) {
		[0]=>
		array(3) {
		["dato"]=>
		string(6) "321530"
		["error"]=>
		string(4) "type"
		["error_msg"]=>
		string(7) "invalid"
		}
	}
	["correo"]=>
	array(1) {
		[0]=>
		array(3) {
		["dato"]=>
		string(3) "a@b"
		["error"]=>
		string(4) "type"
		["error_msg"]=>
		string(17) "correo no válido"
		}
	}
	["calle"]=>
	array(1) {
		[0]=>
		array(3) {
		["dato"]=>
		string(1) "0"
		["error"]=>
		string(3) "min"
		["error_msg"]=>
		string(18) "el mínimo es de 1"
		}
	}
	["observaciones"]=>
	array(1) {
		[0]=>
		array(3) {
		["dato"]=>
		string(51) "la vida es complicada y bla bla bla bla bla bla bla"
		["error"]=>
		string(3) "max"
		["error_msg"]=>
		string(27) "la longitud maxima es de 40"
		}
	}
	["fecha"]=>
	array(1) {
		[0]=>
		array(3) {
		["dato"]=>
		string(10) "32-09-2019"
		["error"]=>
		string(4) "type"
		["error_msg"]=>
		string(15) "fecha inválida"
		}
	}
	["hora"]=>
	array(1) {
		[0]=>
		array(3) {
		["dato"]=>
		string(8) "24:00:17"
		["error"]=>
		string(4) "type"
		["error_msg"]=>
		string(14) "hora inválida"
		}
	}
	["fuerza"]=>
	array(1) {
		[0]=>
		array(3) {
		["dato"]=>
		string(7) "100.xxx"
		["error"]=>
		string(4) "type"
		["error_msg"]=>
		string(16) "no es un número"
		}
	}
	["felicidad"]=>
	array(1) {
		[0]=>
		array(3) {
		["dato"]=>
		string(4) "0.25"
		["error"]=>
		string(4) "type"
		["error_msg"]=>
		string(24) "no es un número válido"
		}
	}
	["hora_almuerzo"]=>
	array(1) {
		[0]=>
		array(3) {
		["dato"]=>
		string(8) "13:30:00"
		["error"]=>
		string(3) "max"
		["error_msg"]=>
		string(15) "maximo 10:15:00"
		}
	}
	["hora_cena"]=>
	array(1) {
		[0]=>
		array(3) {
		["dato"]=>
		string(8) "18:00:00"
		["error"]=>
		string(3) "min"
		["error_msg"]=>
		string(16) "mínimo 19:00:00"
		}
	}
	["fecha_nac"]=>
	array(1) {
		[0]=>
		array(3) {
		["dato"]=>
		string(10) "10-12-1902"
		["error"]=>
		string(3) "min"
		["error_msg"]=>
		string(18) "mínimo 01-01-1980"
		}
	}
	["frutas_favoritas"]=>
	array(1) {
		[0]=>
		array(3) {
		["dato"]=>
		array(2) {
			[0]=>
			string(7) "bananas"
			[1]=>
			string(8) "manzanas"
		}
		["error"]=>
		string(3) "min"
		["error_msg"]=>
		string(18) "mínimo 3 opciones"
		}
	}
	}

Para efectuar la validación sobre las operaciones CRUD con los modelos es tan simple como incluir una instancia de la clase Validator:

	$u = DB::table('products')->setValidator(new Validator());
	$rows = $u->where(['cost' => '100X', 'belongs_to' => 90])->get();

El validador es alimentado con los tipos del $schema y es complementado con un array $rules que puede estar presente opcionalmente en cada modelo.

La clase Validator implementa la interfaz IValidator proveyendo un método validate() que recibe un array de reglas a validar, un array asociativo con los datos y opcionalmente un array de campos sobre los que se deben saltear las validaciones.

	mixed : validate(array $rules, array $data, array $ignored_fields = null, bool $as_string = false)

El método validate() devuelve TRUE si no detectó reglas rotas y caso contrario devolverá un array con los errores como vimos previamente.

Es posible desactivar el chequeo de campos requeridos para todos los campos llamando al método setRequired(false).

Ejemplo:

$data  = [ ..., ... , ...];
$rules = [ ..., ... , ...];
$validado = (new Validator())->setRequired(false)->validate($rules,$data);


# ACL

La implementación del ACL es parecido al de Linux, habiendo permisos a nivel de rol, para un "grupo" de usuarios y para "otros".

Nota:

    Cada entidad que se desee exponer a través de un endpoint debe tener un su modelo asociado un campo tipo entero `belongs_to` -idealmente una FK- que almacenará el id del usuario dueño del recurso. Este es un requisito para el funcionamiento correcto del ACL.

El framework maneja varias tablas para implementar el ACL, entre ellas `group_permissions` se encarga de mantener los permisos de lectura y escritura concedidos por el usuario (owner del recurso) a cierto grupo de usuarios "miembros" del grupo.

Como regla general un usuario puede solo visualizar aquellos registros que ha creado y por tanto le pertenecen pero si se desea que los registros puedan ser leídos o escritos por los demás usuarios registrados (siempre de acuerdo a sus permisos sobre esa tabla de acuerdo a su rol) se puede especificar la propiedad estática $owned = false como sigue:

class Products extends MyApiController
{ 
    static protected $owned = false;
	// ..

También existen permisos para "otros" o sea para cualquier otro usuario sin necesidad de especificarlo. Los permisos para "otros" pueden ser para invitados ("guest") o sea visitantes que no han entregado credenciales.

Los usuarios no registrados o "invitados" (guest) solo pueden visualizar registros pertenecientes a carpetas compartidas con "otros" especificando acceso para invitados.

Es posible hacer que un invitado visualice todos los registros (que no pertenezcan a carpetas que de por si son privadas excepto se expongan con permisos para grupo y otros) especificando en la api la propiedad estática $guest_access = true

class Products extends MyApiController
{ 
    static protected $guest_access = true;
	// ...


Si se desea que todos los endpoints posean guest_access por ejemplo el lugar adecuado para especificarlo es en ela clase MyApiController

class MyApiController extends ApiController
{
    static protected $guest_access = true;
	// ..

### Roles

Se pueden crear distintos roles que son mantenidos en la tabla 'roles' y cuyo fin es limitar las acciones CRUD que puedan realizar.

Para cada endpoint es posible especificar un conjunto de permisos para cada rol ya sea 'read', 'write' o inclusive ser más específico con 'create', 'read', 'delete' y 'update'.

	protected $scope = [
	    'guest'   => ['read'],  
	    'basic'   => ['read'],
	    'regular' => ['read', 'write'],
	    'admin'   => ['read', 'write']
	];

El rol "guest" se obtiene al hacer consulta a un endpoint sin haber presentado antes credenciales (estar autenticado).

Un "guest" o invitado no puede en principio visualizar registros que no pertenezcan a folders con permiso de lectura para "otros" especificando que sea también para guests.

Si se necesitara que los invitados pudieran visualizar registros a nivel de root (no folders) creados por cualquier usuario se puede lograr seteando en el ApiController: 

    static protected $guest_access = true;

En principio es mejor que $guest_access esté en false ya que sino se daría el caso donde un invitado tiene más nivel de acceso que un usuario registrado ya que podría visualizar registros que no le pertenecen mientras que el usuario registrado no puede. (Podría enmendarse)


### Folders

Sobre cada recurso se pueden crear espacios virtuales separados llamados "folders" a los cuales se les pueden establecer permisos para que otros usuarios los visualicen. 

Los folders no tienen nada que ver con el sistema de archivos sino que representan un conjunto de registros de una entidad particular sobre los que se pueden establecer permisos de forma unificada. 

Cada folder existe como un registro distinto en la tabla "folders" y se asocia con una determinada entidad (productos, usuarios, etc) y con un campo en esa entidad conteniendo un valor específico. Para cada endpoint se define el nombre del campo que se asocia al folder, ejemplo:


	class Products extends MyApiController
	{ 
	    protected $folder_field = 'workspace';

	    function __construct()
	    {       
	        parent::__construct();
	    }	        
	} 

El campo $folder_field almacena el nombre del campo que en el ejemplo es "workspace".

Para acceder a un folder se especifica el id del folder y otros usuarios pueden entonces listar o visualizar recursos que se le hayan compartido.

	GET /api/v1/v1/products?folder=1

Por supuesto pueden aplicarse otros filtros:

	GET /api/v1/products?folder=1&cost=200

Y puede visualizarse un registro en particular (ej: 124) para el que no tendríamos permiso si no especificamos el folder:

	GET /api/v1/products/124?folder=1		

Un usuario con rol de administrador en principio obtendrá todos los registros para un endpoint incluidos los que pertenecen a folders privados de otros usuarios:

	GET /api/v1/products

<-- obtiene todos los registros indiscriminadamente

Sin embargo también puede restringir a un folder en particular:

	GET /api/v1/products?folder=57

Los permisos para los folders se conceden creando entradas en la tabla group_permissions y es importante notar que debe darse explícitamente permiso al owner (así como a los otros usuarios) para que éste ver registros dentro de ese folder.

Obviamente cada usuario puede listar, editar o borrar sus folders usando el endpoint /api/v1/folders

Igualmente cada usuario puede hacer CRUD sobre los permisos de "grupo" y para "otros" a través de sus respectivos endpoints /api/v1/GroupPermissions y /api/v1/OtherPermissions respectivamente de modo de permitir a otros miembros acceso de lectura y/o escritura de sus registros.

Para crear un registro en un folder del que se ha concedido permiso de escritura se incluye como campo el id del "folder". Ej:

	POST /api/v1/products

	{
		"name": "Supreme jugo",
	    "description": "de manzanas exprimidas",
	    "size": "1L",
	    "cost": "250",
	    "folder": "8"
	}

O bien se especifica en el "campo clave" que hace identifica al folder, en nuestro caso llamado "workspace" con el valor que corresponda para el folder:

	{
		"name": "Supreme jugo",
	    "description": "de manzanas exprimidas",
	    "size": "1L",
	    "cost": "250",
	    "workspace": "lista10"
	}

En el primer caso, si se especifica un folder pero no tenemos acceso recibiremos un mensaje de error como:

	{
	    "error": "You have not permission for the folder 8"
	}

En el segundo caso donde especificamos "workspace": "lista10" en vez de "folder": "8", si el folder no existe no habrá advertencia alguna pues solo estamos creando un registro con esa combinación de campos y distintos usuarios pueden tener folders con el mismo nombre así que no hay problema.

Es importante entender que cuando creamos un registro dentro de un folder que no nos pertenece (porque se nos da permiso de escritura), el registro tampoco será de nuestra propiedad aunque podremos leerlo y escribirlo siempre que tengamos los permisos para ello.

Igualmente para modificar un registro de otro usuario que nos ha compartido su folder especificamos el id del folder:

	PUT /api/v1/products/136

	{
	    "name": "Vodka venezolano",
	    "description": "de Vzla",
	    "size": "1L",
	    "cost": "15",
	    "folder": "1"
	}

Mismo para borrar un registro perteneciente a un folder es necesario estar "dentro" haciendo referencia al folder en cuestión:

	DELETE /api/v1/products/136

	{
    	"folder": "1"
	}


### Soft delete y el la papelera

En cada endpoint se puede definir si se habilita el "soft" delete mediante la propiedad $soft_delete en la api. Ejemplo:

class Products extends MyApiController
{ 
	// solo hard delete
    protected $soft_delete = false;

    // ...


La única forma de visualizar registros borrados de forma "suave" así como recuperarlos o borrarlos definitivamente es mediante la papelera con la ventaja de que ésta tiene sus propios permisos.


### La Papelera

Cuando un registro es marcado como borrado aparece en TrashCan, la papelera de reciclaje, que brinda la posibilidad de gestionar todas las operaciones sobre elementos eliminados.

Para ver elementos en la papelera

	GET /api/v1/TrashCan?entity=products
	GET /api/v1/TrashCan/157?entity=products


Para hacer un "undelete" de un recurso se hace un PATCH o PUT sobre el TrashCan

	PATCH /api/v1/TrashCan/157	

	{
		"entity": "Products",
		"trashed": "false"
	}

Para eliminar *permanentemente* un recurso se realiza un DELETE sobre el elemento en la papelera:

	DELETE /api/v1/TrashCan/157

	{
    	"entity": "Products"
	}

La papelera acepta los mismos filtros y los resultados se pueden ordenar igual que con cualquier entidad:

	GET /api/v1/TrashCan?entity=Products&order[deleted_at]=DESC


### Registros bloqueados

El admin puede colocar un "lock" sobre registros impidiendo que:

- Puedan ser modificados por el propietario. Le arrojará un código 403. 
- No puedan ser borrados. Le arrojará un código 403. 
- No puedan ser vistos en la papelera por el propietario. Le arrojará un codigo 403. 
- No puedan ser recuperados por el propietario. Le arrojará un código 403. 
- No puedan ser borrados permanentemente por el propietario cuando se hayan en la papelera. 

Cuando un registro es borrado por el Admin éste es bloqueado para el usuario propietario evitando así que pueda modificarlo, recuperarlo o borrarlo permanentemente.

Implementación:

Una entidad correspondiente a un endpoint si contiene un campo 'locked' de tipo "bool" (TINYINT para Mysql) entonces queda habilitada para el mecanismo de "bloqueo".


# La API

### Las respuestas de la API

Una respuesta exitosa a un GET presenta un campo 'data' en la respuesta:

{
    "data": {
        "id": "185",
        "name": "ABC",
        "description": "",
        "size": "",
        "cost": "0",
        "created_at": "2019-11-03 23:55:18",
        "updated_at": null,
        "deleted_at": null,
        "locked": "0",
        "workspace": null,
        "belongs_to": "132"
    },
    "error": "",
    "error_detail": ""
}

En cambio una respuesta que contiene un error, puede o no poseer cuerpo pudiendo ser solo el código de estaus http o bien incluir también un cuerpo con los campos "error" y "error_detail"

{
    "error": "Not found",
    "error_detail": "Register for id=1850 does not exists"
}

# NGINX web server

Agregar en el bloque lo siguiente:

	location /{
		rewrite ^([^.]*[^/])$ $1/ permanent;
		try_files $uri $uri/ /index.php?q=$uri&$args;
	}
	
	
# Opciones para los menús

Se sugiere crear una entidad "Views" que contenga todas las urls de las vistas listadas y otra "RoleViews" asociada a la primera.

Al hacer un GET a Views se listarían todas las urls de vistas para los roles del usuario en particular pero podría filtrarse por un rol específico:

GET /api/v1/views?rol=admin
  